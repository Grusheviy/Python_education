# Функция — это фрагмент программы, используемый многократно
'''
def sum_numbers(n):
    sum = 0
    for i in range(1, n+1):
        sum += i
    print(sum)
sum_numbers(5)
'''
'''     
def sum_numbers(n):
    sum = 0
    for i in range(1, n+1):
        sum += i
    return sum

a = sum_numbers(5)
print(a)    # можно выводить без а сразу print(sum_numbers(5))  
'''
'''
def sum_numbers(n, y = 'hello'):
    print(y)
    sum = 0
    for i in range(1, n+1):
        sum += i
    print(sum)

sum_numbers(5)
'''
'''
def sum_str(*args):
    res = ''
    for i in args:
        res += i 
    return res
print(sum_str('q', 'e', 'l'))
print(sum_str('q', 'e', 'l', 'e', 'l', 'e', 'l'))
print(sum_str('1', '8', '9'))
'''

# Модульность
# Вы когда-нибудь задавались вопрос, как например работает функция .append
# Это же точно такая же функция, как и sumNumbers(n), но мы ее нигде не создаем,
# все дело в том что, это функция автоматически срабатывает и чтобы ей
# пользоваться ничего дополнительно писать не надо.
# Представьте себе такую ситуацию, что Вы создаете огромный проект и у Вас
# имеется большое количество функций, к примеру 5 функций работают со
# словарями, 18 со списками и тд. и у каждой функции свой алгоритм, но их
# объединяет работа с одной коллекцией данных. Согласитесь неудобно работать в
# таком большом файле, где около 80 функций, очень легко потеряться и на
# перемотку кода Вы будете терять драгоценное время. Решение данной проблемы
# есть. Давай будем создавать отдельные файлы, где будут находиться только
# функции, и эти функции при необходимости вызывать из главного файла.

'''
import moduls
import moduls as m1  # импортируем модуль moduls и задаем название m1
from moduls import max1 #
from moduls import * # импортирует все функции из moduls

print(moduls.max1(9, 5))
print(max1(9, 5))
print(m1.max1(9, 5))
'''

# Рекурсия — это функция, вызывающая сама себя.
# При описании рекурсии важно указать, когда функции надо
# остановиться и перестать вызывать саму себя. По-другому говоря, необходимо
# указать базис рекурсии
'''
def fib(n):
    if n in [1, 2]: # описываем базис
        return 1
    return fib(n - 1) + fib(n - 2) # Описываем саму рекурсию    

list_1 = []
for i in range(1, 10):
    list_1.append(fib(i)) # Вызываем саму рекурсию
print(list_1)
'''

# Алгоритмом называется набор инструкций для выполнения некоторой задачи. В
# принципе, любой фрагмент программного кода можно назвать алгоритмом, но мы с
# Вами рассмотрим 2 самых интересных алгоритмы сортировок:
# ●Быстрая сортировка
# ●Сортировка слиянием

# Быстрая сортировка
# “Программированиеэторазбиениечего-тобольшогоиневозможногоначто-то
# маленькое и вполне реальное”
# Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”.
# Сначала рассмотрим пример, затем напишем программный код
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой
# должен отгадать. Согласитесь, что мы можем перебирать эти значения в случайном
# порядке, например: 32, 27, 60, 73... Да, мы можем угадать в какой-то момент, но что
# если мы обратиться к стратегии “разделяй и властвуй” Обозначим друзей, друг_1
# это Иван, который загадал число, друг_2 это Петр, который отгадывает.
'''
def quick_sort(array):
    if len(array) <= 1:
        return array
    else:
        pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i >= pivot]
    #return quick_sort(less) + [pivot] + quick_sort(greater) # будет ошибка потму что нельзя складывать списки с числом(pivot) 
    return quick_sort(less) + [pivot] + quick_sort(greater)
    
print(quick_sort([1,14,5,9,6,24,62,51,2,4,67,8])) 
'''

# Сортировка слиянием 

def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums) // 2
        left = nums[:mid]
        right = nums[mid:]
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            nums[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            nums[k] = right[j]
            j += 1
            k += 1


list_1 = [1,5,4,7,2,9,4,7,14,6,14,6,24,62,2]
merge_sort(list_1)
print(list_1)